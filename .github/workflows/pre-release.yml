name: Pre-Release (Dev)

on:
  push:
    branches:
      - main
      - master

env:
  REGISTRY: ghcr.io

jobs:
  # Job 1: Calculate version and prepare release info (fast, runs first)
  prepare-release:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      tag_name: ${{ steps.version.outputs.tag_name }}
      dev_version: ${{ steps.version.outputs.dev_version }}
      commits: ${{ steps.commits.outputs.commits }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: package-lock.json

      - name: Install dependencies (minimal)
        run: npm ci

      - name: Get current version and determine next dev version
        id: version
        run: |
          # Get current version from package.json
          BASE_VERSION=$(node -p "require('./package.json').version")
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT

          # Fetch all tags
          git fetch --tags --force

          # Find the latest dev tag (e.g., v1.0.3-dev)
          LATEST_DEV_TAG=$(git tag -l "*-dev" | sort -V | tail -1)

          # Find the latest formal release tag (e.g., v1.0.3)
          LATEST_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)

          # Determine base version and tag to compare against
          if [ -n "$LATEST_DEV_TAG" ]; then
            BASE_VERSION_FOR_COMPARE=$(echo "$LATEST_DEV_TAG" | sed 's/^v\(.*\)-dev$/\1/')
            BASE_TAG_FOR_COMPARE="$LATEST_DEV_TAG"
            echo "Latest dev tag: $LATEST_DEV_TAG (version: $BASE_VERSION_FOR_COMPARE)"
          elif [ -n "$LATEST_RELEASE_TAG" ]; then
            BASE_VERSION_FOR_COMPARE=$(echo "$LATEST_RELEASE_TAG" | sed 's/^v//')
            BASE_TAG_FOR_COMPARE="$LATEST_RELEASE_TAG"
            echo "Latest release tag: $LATEST_RELEASE_TAG (version: $BASE_VERSION_FOR_COMPARE)"
          else
            BASE_VERSION_FOR_COMPARE="$BASE_VERSION"
            BASE_TAG_FOR_COMPARE=""
            echo "No existing tags found, using base version: $BASE_VERSION"
          fi

          # Analyze commits to determine version increment (manual implementation)
          INCREMENT_TYPE=$(node -e "
            const { execSync } = require('child_process');
            
            const baseTag = '$BASE_TAG_FOR_COMPARE';
            
            // Get commits since base tag using a delimiter that won't appear in commit messages
            const commitRange = baseTag ? \`\${baseTag}..HEAD\` : 'HEAD';
            const commitOutput = execSync(\`git log \${commitRange} --pretty=format:'%H|||%s|||%b' --reverse\`, { encoding: 'utf8' });
            const commitLines = commitOutput.trim().split('\\n').filter(c => c.trim());
            
            // Analyze commits using conventional commit rules
            let hasBreaking = false;
            let hasFeat = false;
            let hasFix = false;
            
            for (const line of commitLines) {
              const parts = line.split('|||');
              const subject = (parts[1] || '').trim();
              const body = (parts[2] || '').trim();
              
              // Check for breaking changes (highest priority)
              if (subject.match(/^[a-z]+(\([^)]+\))?!:/) || body.match(/BREAKING CHANGE/i)) {
                hasBreaking = true;
                break;
              }
              
              // Check for feat commits
              if (subject.match(/^feat(\([^)]+\))?:/)) {
                hasFeat = true;
              }
              
              // Check for fix commits
              if (subject.match(/^fix(\([^)]+\))?:/)) {
                hasFix = true;
              }
            }
            
            // Determine increment type (breaking > feat > fix)
            if (hasBreaking) {
              console.log('major');
            } else if (hasFeat) {
              console.log('minor');
            } else if (hasFix) {
              console.log('patch');
            } else {
              console.log('patch');
            }
          " || echo "patch")

          # Clean and validate increment type
          INCREMENT_TYPE=$(echo "$INCREMENT_TYPE" | tr -d '\n' | tr '[:upper:]' '[:lower:]')
          if [ "$INCREMENT_TYPE" != "major" ] && [ "$INCREMENT_TYPE" != "minor" ] && [ "$INCREMENT_TYPE" != "patch" ]; then
            INCREMENT_TYPE="patch"
          fi

          echo "Recommended bump type: $INCREMENT_TYPE"

          # Use semver to increment version
          DEV_VERSION=$(node -e "const semver = require('semver'); console.log(semver.inc('$BASE_VERSION_FOR_COMPARE', '$INCREMENT_TYPE'));")
          echo "Incrementing $INCREMENT_TYPE version: $BASE_VERSION_FOR_COMPARE -> $DEV_VERSION"

          TAG_NAME="v${DEV_VERSION}-dev"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "dev_version=$DEV_VERSION" >> $GITHUB_OUTPUT
          echo "Final dev tag: $TAG_NAME (version: $DEV_VERSION)"

      - name: Get commits since previous dev release
        id: commits
        run: |
          # Find the previous dev tag
          PREVIOUS_DEV_TAG=$(git tag -l "*-dev" | sort -V | tail -2 | head -1)

          # Determine which tag to use as the base
          if [ -n "$PREVIOUS_DEV_TAG" ]; then
            BASE_TAG="$PREVIOUS_DEV_TAG"
            echo "Using previous dev tag: $BASE_TAG"
          else
            # No previous dev tag, use latest formal release or all commits
            PREVIOUS_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)
            if [ -n "$PREVIOUS_RELEASE_TAG" ]; then
              BASE_TAG="$PREVIOUS_RELEASE_TAG"
              echo "Using previous release tag: $BASE_TAG"
            else
              BASE_TAG=""
              echo "No previous tags found, using all commits"
            fi
          fi

          # Get commits between BASE_TAG and HEAD, filtering for conventional commits only
          # Pattern matches: type(scope): or type: (with optional scope)
          # Use || true to prevent grep from failing when no matches are found
          if [ -z "$BASE_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s|%h|%H" --reverse | (grep -E "^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:" || true) | head -20)
          else
            COMMITS=$(git log ${BASE_TAG}..HEAD --pretty=format:"%s|%h|%H" --reverse | (grep -E "^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:" || true))
          fi

          if [ -z "$COMMITS" ]; then
            COMMITS_LIST="- No conventional commits since previous release"
          else
            COMMITS_LIST=$(echo "$COMMITS" | while IFS='|' read -r subject hash fullhash; do
              echo "- $subject ([${hash:0:7}](https://github.com/${{ github.repository }}/commit/$fullhash))"
            done)
          fi

          # Store in output
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # Job 2: Update version and commit (runs in parallel with Docker build)
  update-version:
    runs-on: ubuntu-latest
    needs: prepare-release
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: |
            package-lock.json
            server/package-lock.json
            client/package-lock.json

      - name: Install dependencies
        run: |
          npm ci
          cd server && npm ci
          cd ../client && npm ci

      - name: Update version in package.json files
        run: |
          DEV_VERSION="${{ needs.prepare-release.outputs.dev_version }}"
          DEV_VERSION_WITH_SUFFIX="${DEV_VERSION}-dev"
          echo "Updating version to $DEV_VERSION_WITH_SUFFIX in all package.json files"
          npm pkg set version="$DEV_VERSION_WITH_SUFFIX"
          cd server && npm pkg set version="$DEV_VERSION_WITH_SUFFIX"
          cd ../client && npm pkg set version="$DEV_VERSION_WITH_SUFFIX"
          cd ..

      - name: Commit version update
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet package.json server/package.json client/package.json; then
            echo "No version changes to commit"
          else
            git add package.json server/package.json client/package.json
            git commit -m "chore: bump version to ${{ needs.prepare-release.outputs.dev_version }}-dev [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
            echo "âœ“ Committed version update to ${{ needs.prepare-release.outputs.dev_version }}-dev"
          fi

      - name: Create git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.prepare-release.outputs.tag_name }}" -m "Pre-release ${{ needs.prepare-release.outputs.tag_name }}"
          git push origin "${{ needs.prepare-release.outputs.tag_name }}"

  # Job 3: Build Docker image (amd64 only for dev - faster)
  build-docker:
    runs-on: ubuntu-latest
    needs: [prepare-release, update-version]
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # Fetch the latest from branch to get version update from update-version job
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "22"

      - name: Update version in package.json files for Docker build
        run: |
          DEV_VERSION="${{ needs.prepare-release.outputs.dev_version }}"
          DEV_VERSION_WITH_SUFFIX="${DEV_VERSION}-dev"
          echo "Ensuring version is $DEV_VERSION_WITH_SUFFIX in all package.json files for Docker build"
          # Fetch latest from branch to get version update from update-version job
          git fetch origin
          # Update version in package.json files (in case update-version job hasn't committed yet)
          npm pkg set version="$DEV_VERSION_WITH_SUFFIX"
          cd server && npm pkg set version="$DEV_VERSION_WITH_SUFFIX"
          cd ../client && npm pkg set version="$DEV_VERSION_WITH_SUFFIX"
          cd ..
          echo "âœ“ Version set to $DEV_VERSION_WITH_SUFFIX for Docker build"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image (amd64 only for dev)
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository }}:${{ needs.prepare-release.outputs.dev_version }}-dev
            ${{ env.REGISTRY }}/${{ github.repository }}:dev
          build-args: |
            NODE_ENV=production
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

  # Job 4: Create GitHub release (runs after version update and Docker build)
  create-release:
    runs-on: ubuntu-latest
    needs: [prepare-release, update-version, build-docker]
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Create GitHub Pre-Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ needs.prepare-release.outputs.tag_name }}"
          DEV_VERSION="${{ needs.prepare-release.outputs.dev_version }}"
          RELEASE_NAME="v$DEV_VERSION-dev"
          RELEASE_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')

          PREVIOUS_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)
          if [ -n "$PREVIOUS_RELEASE_TAG" ]; then
            CHANGELOG_LINK="[${PREVIOUS_RELEASE_TAG}...${TAG_NAME}](https://github.com/${{ github.repository }}/compare/${PREVIOUS_RELEASE_TAG}...${TAG_NAME})"
          else
            CHANGELOG_LINK="[${TAG_NAME}](https://github.com/${{ github.repository }}/commits/${TAG_NAME})"
          fi

          RELEASE_BODY=$(cat <<EOF
          **Docker Images:**
          - \`${{ env.REGISTRY }}/${{ github.repository }}:$DEV_VERSION-dev\`
          - \`${{ env.REGISTRY }}/${{ github.repository }}:dev\`

          **Released at:** $RELEASE_DATE

          ---

          ## ðŸ“ Commits in This Release

          ${{ needs.prepare-release.outputs.commits }}

          ---

          $CHANGELOG_LINK
          EOF
          )

          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes "$RELEASE_BODY" \
            --prerelease \
            --repo ${{ github.repository }}

          echo "âœ“ Created GitHub pre-release: $TAG_NAME"
