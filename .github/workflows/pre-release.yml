name: Pre-Release (Dev)

on:
  push:
    branches:
      - main
      - master

env:
  REGISTRY: ghcr.io

jobs:
  pre-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Get current version and determine next dev version
        id: version
        run: |
          # Get current version from package.json
          BASE_VERSION=$(node -p "require('./package.json').version")
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          
          # Fetch all tags
          git fetch --tags --force
          
          # Find the latest dev tag (e.g., v1.0.3-dev)
          LATEST_DEV_TAG=$(git tag -l "*-dev" | sort -V | tail -1)
          
          # Find the latest formal release tag (e.g., v1.0.3)
          LATEST_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)
          
          # Determine base version and tag to compare against
          if [ -n "$LATEST_DEV_TAG" ]; then
            BASE_VERSION_FOR_COMPARE=$(echo "$LATEST_DEV_TAG" | sed 's/^v\(.*\)-dev$/\1/')
            BASE_TAG_FOR_COMPARE="$LATEST_DEV_TAG"
            echo "Latest dev tag: $LATEST_DEV_TAG (version: $BASE_VERSION_FOR_COMPARE)"
          elif [ -n "$LATEST_RELEASE_TAG" ]; then
            BASE_VERSION_FOR_COMPARE=$(echo "$LATEST_RELEASE_TAG" | sed 's/^v//')
            BASE_TAG_FOR_COMPARE="$LATEST_RELEASE_TAG"
            echo "Latest release tag: $LATEST_RELEASE_TAG (version: $BASE_VERSION_FOR_COMPARE)"
          else
            BASE_VERSION_FOR_COMPARE="$BASE_VERSION"
            BASE_TAG_FOR_COMPARE=""
            echo "No existing tags found, using base version: $BASE_VERSION"
          fi
          
          # Use @semantic-release/commit-analyzer to determine version increment
          INCREMENT_TYPE=$(node -e "
            (async () => {
              try {
                const analyzeCommits = require('@semantic-release/commit-analyzer');
                const { execSync } = require('child_process');
                
                const baseTag = '$BASE_TAG_FOR_COMPARE';
                
                // Get commits since base tag
                const commitRange = baseTag ? \`\${baseTag}..HEAD\` : 'HEAD';
                const commits = execSync(\`git log \${commitRange} --pretty=format:'%H|%s|%b' --reverse\`, { encoding: 'utf8' })
                  .trim()
                  .split('\\n')
                  .filter(c => c.trim())
                  .map(line => {
                    const [hash, subject, ...bodyParts] = line.split('|');
                    return {
                      hash,
                      message: subject + (bodyParts.length ? '\\n\\n' + bodyParts.join('\\n') : ''),
                      gitTags: baseTag ? [baseTag] : []
                    };
                  });
                
                // Analyze commits with angular preset (conventional commits)
                const result = await analyzeCommits({
                  commits,
                  logger: { 
                    log: (msg) => console.error('LOG:', msg),
                    error: (msg) => console.error('ERROR:', msg)
                  },
                  options: {
                    preset: 'angular'
                  }
                });
                
                console.error('Analysis result:', result, 'Type:', typeof result);
                
                // Map semantic-release result to increment type
                // Result can be: null, false, 'major', 'minor', 'patch', or an object with releaseType
                let incrementType = 'patch';
                
                if (result === null || result === false) {
                  incrementType = 'patch';
                } else if (typeof result === 'string') {
                  incrementType = result;
                } else if (result && result.releaseType) {
                  incrementType = result.releaseType;
                } else if (result === 'major' || result === 'minor' || result === 'patch') {
                  incrementType = result;
                }
                
                console.log(incrementType);
              } catch (err) {
                console.error('Error analyzing commits:', err.message);
                console.error('Stack:', err.stack);
                // Fallback: manually analyze commits
                let hasBreaking = false;
                let hasFeat = false;
                let hasFix = false;
                
                for (const commit of commits) {
                  const msg = commit.message || '';
                  const lines = msg.split('\\n');
                  const subject = lines[0] || '';
                  const body = lines.slice(1).join('\\n');
                  
                  // Check for breaking changes
                  if (subject.match(/^[a-z]+(\(.+\))?!:/) || body.match(/BREAKING CHANGE/i)) {
                    hasBreaking = true;
                    break;
                  }
                  
                  // Check for feat commits
                  if (subject.match(/^feat(\(.+\))?:/)) {
                    hasFeat = true;
                  }
                  
                  // Check for fix commits
                  if (subject.match(/^fix(\(.+\))?:/)) {
                    hasFix = true;
                  }
                }
                
                if (hasBreaking) {
                  console.log('major');
                } else if (hasFeat) {
                  console.log('minor');
                } else if (hasFix) {
                  console.log('patch');
                } else {
                  console.log('patch');
                }
              }
            })();
          " || echo "patch")
          
          # Clean and validate increment type
          INCREMENT_TYPE=$(echo "$INCREMENT_TYPE" | tr -d '\n' | tr '[:upper:]' '[:lower:]')
          if [ "$INCREMENT_TYPE" != "major" ] && [ "$INCREMENT_TYPE" != "minor" ] && [ "$INCREMENT_TYPE" != "patch" ]; then
            INCREMENT_TYPE="patch"
          fi
          
          echo "Recommended bump type: $INCREMENT_TYPE"
          
          # Use semver to increment version
          DEV_VERSION=$(node -e "const semver = require('semver'); console.log(semver.inc('$BASE_VERSION_FOR_COMPARE', '$INCREMENT_TYPE'));")
          echo "Incrementing $INCREMENT_TYPE version: $BASE_VERSION_FOR_COMPARE -> $DEV_VERSION"
          
          TAG_NAME="v${DEV_VERSION}-dev"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "dev_version=$DEV_VERSION" >> $GITHUB_OUTPUT
          echo "Final dev tag: $TAG_NAME (version: $DEV_VERSION)"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker images
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.version.outputs.dev_version }}-dev
            ${{ env.REGISTRY }}/${{ github.repository }}:dev
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Create git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.version.outputs.tag_name }}" -m "Pre-release ${{ steps.version.outputs.tag_name }}"
          git push origin "${{ steps.version.outputs.tag_name }}"

      - name: Get commits since previous dev release
        id: commits
        run: |
          # Find the previous dev tag
          PREVIOUS_DEV_TAG=$(git tag -l "*-dev" | sort -V | tail -2 | head -1)
          
          # Determine which tag to use as the base
          if [ -n "$PREVIOUS_DEV_TAG" ]; then
            BASE_TAG="$PREVIOUS_DEV_TAG"
            echo "Using previous dev tag: $BASE_TAG"
          else
            # No previous dev tag, use latest formal release or all commits
            PREVIOUS_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)
            if [ -n "$PREVIOUS_RELEASE_TAG" ]; then
              BASE_TAG="$PREVIOUS_RELEASE_TAG"
              echo "Using previous release tag: $BASE_TAG"
            else
              BASE_TAG=""
              echo "No previous tags found, using all commits"
            fi
          fi
          
          # Get commits between BASE_TAG and HEAD, filtering for conventional commits only
          # Pattern matches: type(scope): or type: (with optional scope)
          # Use || true to prevent grep from failing when no matches are found
          if [ -z "$BASE_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s|%h|%H" --reverse | (grep -E "^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:" || true) | head -20)
          else
            COMMITS=$(git log ${BASE_TAG}..HEAD --pretty=format:"%s|%h|%H" --reverse | (grep -E "^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:" || true))
          fi
          
          if [ -z "$COMMITS" ]; then
            COMMITS_LIST="- No conventional commits since previous release"
          else
            COMMITS_LIST=$(echo "$COMMITS" | while IFS='|' read -r subject hash fullhash; do
              echo "- $subject ([${hash:0:7}](https://github.com/${{ github.repository }}/commit/$fullhash))"
            done)
          fi
          
          # Store in output
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Pre-Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          DEV_VERSION="${{ steps.version.outputs.dev_version }}"
          RELEASE_NAME="v$DEV_VERSION-dev"
          RELEASE_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          # Get previous release tag for changelog link (Sonarr format: v1.0.0...v1.0.1-dev)
          PREVIOUS_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)
          if [ -n "$PREVIOUS_RELEASE_TAG" ]; then
            CHANGELOG_LINK="[${PREVIOUS_RELEASE_TAG}...${TAG_NAME}](https://github.com/${{ github.repository }}/compare/${PREVIOUS_RELEASE_TAG}...${TAG_NAME})"
          else
            CHANGELOG_LINK="[${TAG_NAME}](https://github.com/${{ github.repository }}/commits/${TAG_NAME})"
          fi
          
          RELEASE_BODY=$(cat <<EOF
          **Docker Images:**
          - \`${{ env.REGISTRY }}/${{ github.repository }}:$DEV_VERSION-dev\`
          - \`${{ env.REGISTRY }}/${{ github.repository }}:dev\`
          
          **Released at:** $RELEASE_DATE
          
          ---
          
          ## ðŸ“ Commits in This Release
          
          ${{ steps.commits.outputs.commits }}
          
          ---
          
          $CHANGELOG_LINK
          EOF
          )
          
          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes "$RELEASE_BODY" \
            --prerelease \
            --repo ${{ github.repository }}
          
          echo "âœ“ Created GitHub pre-release: $TAG_NAME"

