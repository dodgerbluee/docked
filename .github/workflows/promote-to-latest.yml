name: Promote Dev to Latest

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "promote" to confirm promoting dev to latest'
        required: true
        type: string
      create_release:
        description: 'Create a GitHub release for this promotion'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io

jobs:
  promote:
    runs-on: ubuntu-latest 
    if: github.event.inputs.confirm == 'promote'
    permissions:
      contents: write
      packages: write
      pull-requests: read
      issues: read
    steps:
      - name: Check repository permissions
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            // Get the actor (user who triggered the workflow)
            const actor = context.actor;
            
            // Check if user is owner
            const isOwner = repo.owner.login.toLowerCase() === actor.toLowerCase();
            
            // Check if user has admin permissions
            let hasAdmin = false;
            try {
              const { data: permissions } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: actor
              });
              hasAdmin = permissions.permission === 'admin';
            } catch (error) {
              // If we can't check permissions, assume not admin
              hasAdmin = false;
            }
            
            if (!isOwner && !hasAdmin) {
              core.setFailed('Only repository owners and admins can promote to latest. You must be the repository owner or have admin permissions.');
            }
            
            core.info(`User ${actor} is ${isOwner ? 'owner' : hasAdmin ? 'admin' : 'not authorized'}`);

      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Set up Node.js
        if: github.event.inputs.create_release == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: '18'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if dev image exists
        run: |
          if ! docker manifest inspect ${{ env.REGISTRY }}/${{ github.repository }}:dev > /dev/null 2>&1; then
            echo "‚ùå Error: dev image not found at ${{ env.REGISTRY }}/${{ github.repository }}:dev"
            echo "Please ensure a dev image has been built first."
            exit 1
          fi
          echo "‚úì Found dev image"

      - name: Install dependencies
        if: github.event.inputs.create_release == 'true'
        run: npm install

      - name: Get version from latest dev tag
        id: version
        if: github.event.inputs.create_release == 'true'
        run: |
          # Fetch all tags
          git fetch --tags --force
          
          # Find the latest dev tag (e.g., v1.0.3-dev)
          LATEST_DEV_TAG=$(git tag -l "*-dev" | sort -V | tail -1)
          
          if [ -z "$LATEST_DEV_TAG" ]; then
            echo "‚ùå Error: No dev tag found. Please ensure a dev pre-release has been created first."
            exit 1
          fi
          
          # Extract version from dev tag (e.g., v1.0.3-dev -> 1.0.3)
          RELEASE_VERSION=$(echo "$LATEST_DEV_TAG" | sed 's/^v\(.*\)-dev$/\1/')
          TAG_NAME="v${RELEASE_VERSION}"
          
          echo "Latest dev tag: $LATEST_DEV_TAG"
          echo "Release version: $RELEASE_VERSION"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "Final tag: $TAG_NAME (version: $RELEASE_VERSION)"

      - name: Update version in package.json files
        if: github.event.inputs.create_release == 'true'
        run: |
          RELEASE_VERSION="${{ steps.version.outputs.release_version }}"
          echo "Updating version to $RELEASE_VERSION in all package.json files"
          # Update root package.json
          npm pkg set version="$RELEASE_VERSION"
          # Update server package.json
          cd server && npm pkg set version="$RELEASE_VERSION"
          # Update client package.json
          cd ../client && npm pkg set version="$RELEASE_VERSION"
          cd ..
          echo "‚úì Version updated to $RELEASE_VERSION"

      - name: Commit version update
        if: github.event.inputs.create_release == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are changes to commit
          if git diff --quiet package.json server/package.json client/package.json; then
            echo "No version changes to commit"
          else
            git add package.json server/package.json client/package.json
            git commit -m "chore: bump version to ${{ steps.version.outputs.release_version }} [skip ci]"
            # Get the current branch
            BRANCH=$(git rev-parse --abbrev-ref HEAD)
            git push origin HEAD:$BRANCH
            echo "‚úì Committed version update to ${{ steps.version.outputs.release_version }}"
          fi

      - name: Build and push Docker image with release version
        if: github.event.inputs.create_release == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.version.outputs.release_version }}
            ${{ env.REGISTRY }}/${{ github.repository }}:latest
          build-args: |
            NODE_ENV=production
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

      - name: Tag dev as latest (simple promotion without release)
        if: github.event.inputs.create_release != 'true'
        run: |
          # Use buildx imagetools to copy the multi-arch manifest from dev to latest
          # This preserves all architectures (linux/amd64, linux/arm64) in the manifest list
          docker buildx imagetools create \
            --tag ${{ env.REGISTRY }}/${{ github.repository }}:latest \
            ${{ env.REGISTRY }}/${{ github.repository }}:dev
          
          echo "‚úì Successfully promoted dev to latest (multi-arch manifest preserved)"

      - name: Get commits since previous release
        id: commits
        if: github.event.inputs.create_release == 'true'
        run: |
          # Find the latest formal release tag (excluding dev and latest tags)
          PREVIOUS_RELEASE_TAG=$(git tag -l "v*" | grep -v "dev" | grep -v "latest" | sort -V | tail -1)
          
          # Determine which tag to use as the base
          if [ -n "$PREVIOUS_RELEASE_TAG" ]; then
            BASE_TAG="$PREVIOUS_RELEASE_TAG"
            echo "Using previous release tag: $BASE_TAG"
          else
            BASE_TAG=""
            echo "No previous release tags found, using all commits"
          fi
          
          # Get commits between BASE_TAG and HEAD, filtering for conventional commits only (exclude merge commits)
          # Pattern matches: type(scope): or type: (with optional scope)
          # Use || true to prevent grep from failing when no matches are found
          if [ -z "$BASE_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s|%h|%H" --reverse | (grep -E "^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:" || true) | head -50)
          else
            COMMITS=$(git log ${BASE_TAG}..HEAD --pretty=format:"%s|%h|%H" --reverse | (grep -E "^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\([^)]+\))?:" || true))
          fi
          
          if [ -z "$COMMITS" ]; then
            COMMITS_LIST="- No conventional commits since previous release"
          else
            COMMITS_LIST=$(echo "$COMMITS" | while IFS='|' read -r subject hash fullhash; do
              echo "- $subject ([${hash:0:7}](https://github.com/${{ github.repository }}/commit/$fullhash))"
            done)
          fi
          
          # Store in output
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_LIST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Also get previous release tag for changelog link
          if [ -n "$PREVIOUS_RELEASE_TAG" ]; then
            echo "previous_tag=$PREVIOUS_RELEASE_TAG" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        id: create_release
        if: github.event.inputs.create_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="${{ steps.version.outputs.tag_name }}"
          RELEASE_VERSION="${{ steps.version.outputs.release_version }}"
          RELEASE_NAME="v$RELEASE_VERSION"
          RELEASE_DATE=$(date -u +'%Y-%m-%d %H:%M:%S UTC')
          
          # Create changelog link in Sonarr format (v1.0.0...v1.0.1)
          if [ -n "${{ steps.commits.outputs.previous_tag }}" ]; then
            PREV_TAG="${{ steps.commits.outputs.previous_tag }}"
            CHANGELOG_LINK="[${PREV_TAG}...${TAG_NAME}](https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${TAG_NAME})"
          else
            CHANGELOG_LINK="[${TAG_NAME}](https://github.com/${{ github.repository }}/commits/${TAG_NAME})"
          fi
          
          RELEASE_BODY=$(cat <<EOF
          **Docker Images:**
          - \`${{ env.REGISTRY }}/${{ github.repository }}:$RELEASE_VERSION\`
          - \`${{ env.REGISTRY }}/${{ github.repository }}:latest\`
          
          **Promoted by:** @${{ github.actor }}
          **Promoted at:** $RELEASE_DATE
          
          ---
          
          ## üìù Commits in This Release
          
          ${{ steps.commits.outputs.commits }}
          
          ---
          
          $CHANGELOG_LINK
          EOF
          )
          
          gh release create "$TAG_NAME" \
            --title "$RELEASE_NAME" \
            --notes "$RELEASE_BODY" \
            --repo ${{ github.repository }}
          
          echo "‚úì Created GitHub release: $TAG_NAME"
          
          # Store the actual release version for the summary
          echo "actual_tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "actual_release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT

      - name: Get image info
        if: github.event.inputs.create_release == 'true'
        run: |
          echo "## Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Successfully promoted **dev** to **latest**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Docker Images:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.REGISTRY }}/${{ github.repository }}:${{ steps.create_release.outputs.actual_release_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.REGISTRY }}/${{ github.repository }}:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**GitHub Release:** Created [${{ steps.create_release.outputs.actual_tag_name }}](https://github.com/${{ github.repository }}/releases/tag/${{ steps.create_release.outputs.actual_tag_name }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Promoted by:** @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Promoted at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  validation:
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm != 'promote'
    steps:
      - name: Validation failed
        run: |
          echo "‚ùå Promotion cancelled. You must type 'promote' in the confirmation field."
          exit 1

